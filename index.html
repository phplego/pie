<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Crypto Market Cap Animation</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      margin: 0;
      padding: 20px;
    }

    /* Two-column layout */
    .container {
      display: flex;
      flex-wrap: wrap;
      width: 100%;
      max-width: 1400px;
      margin: 0 auto;
    }

    .chart-column {
      flex: 1;
      min-width: 300px;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }

    .settings-column {
      flex: 1;
      min-width: 300px;
      padding: 10px;
    }

    #monthLabel { font-size: 1.5rem; margin-bottom: 5px; }
    #loader { font-size: 1rem; color: #555; margin-top: 20px; }
    #error { color: red; font-weight: bold; margin-top: 10px; }
    canvas { width: 100%; max-width: 600px; margin: 0; padding: 0; }
    button { margin-top: 10px; padding: 8px 16px; font-size: 1rem; }
    #clearCacheBtn { background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; }

    /* Crypto checkboxes */
    .crypto-options {
      margin-top: 20px;
      padding: 15px;
      background-color: #f9f9f9;
      border-radius: 5px;
    }

    .crypto-option {
      margin-bottom: 10px;
      display: flex;
      align-items: center;
    }

    .crypto-option input {
      margin-right: 10px;
    }

    .crypto-color {
      display: inline-block;
      width: 15px;
      height: 15px;
      border-radius: 50%;
      margin-right: 10px;
    }

    .settings-title {
      font-size: 1.2rem;
      margin-bottom: 15px;
      font-weight: bold;
    }

    /* Progress slider styles */
    #progressContainer {
      width: 100%;
      max-width: 600px;
      margin: 10px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #progressSlider {
      width: 100%;
      height: 20px;
      margin: 10px 0;
      -webkit-appearance: none;
      appearance: none;
      background: #f0f0f0;
      outline: none;
      border-radius: 5px;
      cursor: pointer;
    }
  </style>
</head>
<body>
<div class="container">
  <!-- Left column - Chart -->
  <div class="chart-column">
    <div id="monthLabel"></div>
    <div id="progressContainer" style="display:none;">
      <input type="range" id="progressSlider" min="0" max="0" value="0">
    </div>
    <canvas id="pieChart" style="display:none;"></canvas>
  </div>

  <!-- Right column - Settings -->
  <div class="settings-column">
    <div id="loader">Loading data...</div>
    <div id="error" style="display:none;"></div>

    <div class="crypto-options" style="display:none;" id="cryptoOptions">
      <div class="settings-title">Cryptocurrencies</div>
      <!-- Checkboxes will be added here dynamically -->
    </div>

    <button id="clearCacheBtn" style="display:none;">Clear Cache</button>
  </div>
</div>

<script>
  // ===== CONFIGURATION SECTION =====
  // Number of years to load and display
  const YEARS_TO_LOAD = 3;

  // Unified cryptocurrency configuration
  const coins = {
    'ADA': {
      color: '#0033ad',      // Cardano blue
      supply: 45000000000,
      displayByDefault: true
    },
    'ETH': {
      color: '#3c3c3d',      // Ethereum dark gray
      supply: 120000000,
      displayByDefault: false
    },
    'BNB': {
      color: '#f3ba2f',      // Binance yellow
      supply: 166801148,
      displayByDefault: true
    },
    'TON': {
      color: '#0088CC',      // TonCoin blue
      supply: 5000000000,
      displayByDefault: true
    },
    'SOL': {
      color: '#14f195',      // Solana green
      supply: 555000000,
      displayByDefault: true
    },
    'USDT': {
      color: '#26a17b',      // Tether green
      supply: 83000000000,
      displayByDefault: false
    },
    'BTC': {
      color: '#f7931a',      // Bitcoin orange
      supply: 21000000,
      displayByDefault: false
    }
  };

  // Define cryptocurrencies to display from the coins object
  const cryptos = Object.keys(coins);

  // Track which cryptocurrencies are enabled (all enabled by default)
  const enabledCryptos = {};

  // Month names for date formatting
  const monthNames = [
    'January', 'February', 'March', 'April', 'May', 'June', 
    'July', 'August', 'September', 'October', 'November', 'December'
  ];

  // Generate array of last N months (newest to oldest)
  const months = [];
  let date = new Date();
  for (let i = 0; i < 12 * YEARS_TO_LOAD; i++) {
    months.unshift(`${monthNames[date.getMonth()]} ${date.getFullYear()}`);
    date.setMonth(date.getMonth() - 1);
  }

  // Initialize market cap and price data structures
  const marketCaps = {};
  const prices = {};
  cryptos.forEach(crypto => {
    marketCaps[crypto] = [];
    prices[crypto] = [];
  });

  // Cache expiration time in milliseconds (1 hour)
  const CACHE_EXPIRATION = 3600 * 1000;

  // Check if valid cache exists and return it
  function checkAndGetCache(symbol) {
    const cacheKey = `${symbol.toLowerCase()}_market_chart`;
    const cachedItem = localStorage.getItem(cacheKey);

    if (!cachedItem) return null;

    try {
      const cache = JSON.parse(cachedItem);
      const timestamp = cache.timestamp;
      const currentTime = new Date().getTime();

      // Check if cache is still valid
      if (currentTime - timestamp < CACHE_EXPIRATION) {
        return cache.data;
      }
    } catch (e) {
      console.error(`Error reading cache for ${symbol}:`, e);
    }

    return null;
  }

  // Save data to localStorage cache
  function saveToCache(symbol, data) {
    const cacheKey = `${symbol.toLowerCase()}_market_chart`;
    const cacheObject = {
      timestamp: new Date().getTime(),
      data: data
    };

    try {
      localStorage.setItem(cacheKey, JSON.stringify(cacheObject));
      console.log(`Cache updated for ${symbol}`);
    } catch (e) {
      console.error(`Error writing cache for ${symbol}:`, e);
      // Handle potential localStorage quota exceeded errors
      if (e.name === 'QuotaExceededError') {
        clearOldestCache();
        try {
          localStorage.setItem(cacheKey, JSON.stringify(cacheObject));
        } catch (e2) {
          console.error(`Still couldn't save cache after clearing:`, e2);
        }
      }
    }
  }

  // Clear oldest cache entry if storage is full
  function clearOldestCache() {
    let oldest = null;
    let oldestKey = null;

    // Find the oldest cache entry
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key.endsWith('_market_chart')) {
        try {
          const cache = JSON.parse(localStorage.getItem(key));
          if (!oldest || cache.timestamp < oldest) {
            oldest = cache.timestamp;
            oldestKey = key;
          }
        } catch (e) {
          console.error(`Error parsing cache:`, e);
        }
      }
    }

    // Remove the oldest entry if found
    if (oldestKey) {
      localStorage.removeItem(oldestKey);
      console.log(`Removed oldest cache: ${oldestKey}`);
    }
  }

  // Process API response into the format expected by the chart
  function processApiResponse(symbol, apiData) {
    // Extract the data points
    const dailyData = apiData.Data.Data;

    // Convert to the format expected by the frontend
    const monthlyData = [];
    let currentMonth = null;

    for (const point of dailyData) {
      const timestamp = point.time;
      // Calculate market cap using the coin supply
      const totalSupply = coins[symbol]?.supply || 1000000;
      const marketCap = point.close * totalSupply;

      // Extract month from timestamp
      const timestampMs = timestamp * 1000;
      const date = new Date(timestampMs);
      const month = date.getMonth();

      if (month !== currentMonth) {
        currentMonth = month;
        // Include price along with timestamp and market cap
        monthlyData.push([timestampMs, marketCap, point.close]);
      }
    }

    return { market_caps: monthlyData };
  }

  // Process API data into the marketCaps and prices arrays
  function processApiData(crypto, data) {
    if (!data.market_caps) {
      throw Error(`Bad data format for ${crypto}`);
    }

    // Extract market cap and price values from response
    marketCaps[crypto] = data.market_caps.map(entry => entry[1] || 0);
    prices[crypto] = data.market_caps.map(entry => entry[2] || 0);
  }

  /**
   * Fetch market cap data for all cryptocurrencies
   * Makes parallel API requests and processes the responses
   */
  async function fetchMarketCaps() {
    try {
      // Fetch data for all cryptocurrencies in parallel
      await Promise.all(cryptos.map(async (crypto) => {
        // Check if we have valid cached data
        const cachedData = checkAndGetCache(crypto);
        if (cachedData) {
          console.log(`Using cached data for ${crypto}`);
          processApiData(crypto, cachedData);
          return;
        }

        // Make direct API request to CryptoCompare
        const url = "https://min-api.cryptocompare.com/data/v2/histoday";
        const params = {
          fsym: crypto,
          tsym: 'USD',
          limit: 365 * YEARS_TO_LOAD,  // Get data for specified years
          aggregate: 1
        };

        const queryString = new URLSearchParams(params).toString();
        const response = await fetch(`${url}?${queryString}`);

        // Handle HTTP errors
        if (!response.ok) {
          throw Error(`Fetch ${crypto} failed with status ${response.status}`);
        }

        // Parse JSON response
        const data = await response.json();

        // Validate response format
        if (data.Response !== 'Success') {
          throw Error(`Bad data format for ${crypto}: ${data.Message || 'Unknown error'}`);
        }

        // Process and cache the data
        const processedData = processApiResponse(crypto, data);
        saveToCache(crypto, processedData);
        processApiData(crypto, processedData);
      }));
    } catch (error) {
      // Log error to console
      console.error(error);

      // Show error with a simple alert
      document.getElementById('loader').style.display = 'none';
      alert('Error fetching data: ' + error.message);

      // Re-throw error to be handled by caller
      throw error;
    }
  }


  // Set up clear cache button click handler
  document.getElementById('clearCacheBtn').onclick = () => {
    // Clear all market chart caches
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.endsWith('_market_chart')) {
        localStorage.removeItem(key);
      }
    }
    alert('Cache cleared. Reloading data...');
    // Restart initialization
    init();
  };

  /**
   * Initialize the progress slider
   */
  function initializeProgressSlider() {
    const slider = document.getElementById('progressSlider');

    // Set slider range based on number of months
    slider.min = 0;
    slider.max = months.length - 1;
    slider.value = 0;

    // Add event listener for slider changes
    slider.addEventListener('input', function() {
      // Update current month index
      window.currentMonthIndex = parseInt(this.value);

      // Update month label
      document.getElementById('monthLabel').textContent = months[window.currentMonthIndex];

      // Update chart
      updateChart();
    });
  }

  /**
   * Initialize cryptocurrency checkboxes
   * Creates a checkbox for each cryptocurrency and adds event listeners
   */
  function initializeCryptoCheckboxes() {
    const cryptoOptionsContainer = document.getElementById('cryptoOptions');

    // Clear any existing checkboxes
    const checkboxesContainer = cryptoOptionsContainer.querySelector('.settings-title').nextElementSibling;
    if (checkboxesContainer) {
      checkboxesContainer.remove();
    }

    // Create container for checkboxes
    const container = document.createElement('div');

    // Initialize cryptocurrencies based on configuration
    cryptos.forEach(crypto => {
      // Use the configuration to determine if this crypto should be enabled by default
      enabledCryptos[crypto] = coins[crypto].displayByDefault;

      // Create checkbox container
      const checkboxContainer = document.createElement('div');
      checkboxContainer.className = 'crypto-option';

      // Create checkbox
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = `checkbox-${crypto}`;
      checkbox.checked = coins[crypto].displayByDefault;

      // Create color indicator
      const colorIndicator = document.createElement('span');
      colorIndicator.className = 'crypto-color';
      colorIndicator.style.backgroundColor = coins[crypto].color;

      // Create label
      const label = document.createElement('label');
      label.htmlFor = `checkbox-${crypto}`;
      label.textContent = crypto;

      // Add event listener to checkbox
      checkbox.addEventListener('change', function() {
        enabledCryptos[crypto] = this.checked;
        updateChart();
      });

      // Append elements to container
      checkboxContainer.appendChild(checkbox);
      checkboxContainer.appendChild(colorIndicator);
      checkboxContainer.appendChild(label);
      container.appendChild(checkboxContainer);
    });

    // Append container to crypto options
    cryptoOptionsContainer.appendChild(container);
  }

  /**
   * Get currently enabled cryptocurrencies
   * @returns {Array} Array of enabled cryptocurrency symbols
   */
  function getEnabledCryptos() {
    return cryptos.filter(crypto => enabledCryptos[crypto]);
  }

  /**
   * Update the chart with current data
   * Called when checkboxes are toggled
   */
  function updateChart() {
    if (window.currentChart && window.currentMonthIndex !== undefined) {
      const enabledCryptosList = getEnabledCryptos();

      // Update chart data
      window.currentChart.data.labels = enabledCryptosList;
      window.currentChart.data.datasets[0].data = calculatePercentages(window.currentMonthIndex, enabledCryptosList);
      window.currentChart.data.datasets[0].backgroundColor = enabledCryptosList.map(crypto => coins[crypto].color);

      // Update chart
      window.currentChart.update();
    }
  }

  /**
   * Initialize the application
   * Fetches data and starts the chart animation
   */
  async function init() {
    try {
      // Fetch market cap data for all cryptocurrencies
      await fetchMarketCaps();

      // Hide loading indicator
      document.getElementById('loader').style.display = 'none';

      // Show chart canvas, progress bar, and crypto options
      document.getElementById('pieChart').style.display = 'block';
      document.getElementById('progressContainer').style.display = 'block';
      document.getElementById('clearCacheBtn').style.display = 'block';
      document.getElementById('cryptoOptions').style.display = 'block';

      // Initialize progress slider and crypto checkboxes
      initializeProgressSlider();
      initializeCryptoCheckboxes();

      // Start the animation sequence
      startAnimation();
    } catch (error) {
      console.log('Initialization failed', error);
    }
  }

  /**
   * Calculate market cap percentages for a specific month
   * @param {number} monthIndex - Index of the month to calculate percentages for
   * @param {Array} [cryptoList] - Optional list of cryptocurrencies to include (defaults to all enabled)
   * @returns {Array} Array of percentage values for each cryptocurrency
   */
  function calculatePercentages(monthIndex, cryptoList) {
    // Use provided crypto list or get enabled cryptos
    const activeCryptos = cryptoList || getEnabledCryptos();

    // Get market cap values for each cryptocurrency at the specified month
    const marketCapValues = activeCryptos.map(crypto => marketCaps[crypto][monthIndex] || 0);

    // Calculate the total market cap
    const totalMarketCap = marketCapValues.reduce((sum, value) => sum + value, 0);

    // Calculate percentage for each cryptocurrency
    // If total is 0, return 0 to avoid division by zero
    return marketCapValues.map(value => 
      totalMarketCap ? ((value / totalMarketCap) * 100).toFixed(2) : 0
    );
  }

  /**
   * Get the price for a specific cryptocurrency at a specific month
   * @param {string} crypto - The cryptocurrency symbol
   * @param {number} monthIndex - Index of the month
   * @returns {string} Formatted price value
   */
  function getPriceAtMonth(crypto, monthIndex) {
    const price = prices[crypto][monthIndex] || 0;
    return price.toFixed(2);
  }

  /**
   * Start the pie chart animation sequence
   * Creates the Chart.js instance and sets up the animation interval
   */
  function startAnimation() {
    // Start with the first month
    window.currentMonthIndex = 0;

    // Get the canvas context for drawing
    const ctx = document.getElementById('pieChart').getContext('2d');

    // Set initial month label
    document.getElementById('monthLabel').textContent = months[window.currentMonthIndex];

    // Get enabled cryptocurrencies
    const enabledCryptosList = getEnabledCryptos();

    // Chart.js configuration
    const chartConfig = {
      type: 'pie',
      data: {
        labels: enabledCryptosList,
        datasets: [{
          data: calculatePercentages(window.currentMonthIndex, enabledCryptosList),
          backgroundColor: enabledCryptosList.map(crypto => coins[crypto].color)
        }]
      },
      options: {
        aspectRatio: 1,
        layout: {
          padding: {
            top: 0,
            bottom: 0
          }
        },
        plugins: {
          // Configure data labels plugin
          datalabels: {
            formatter: (value, context) => {
              const crypto = context.chart.data.labels[context.dataIndex];
              const price = getPriceAtMonth(crypto, window.currentMonthIndex);
              return `${crypto}:\n ${value}%\n $${price}`;
            },
            color: '#fff',
            anchor: 'end',
            align: 'start',
            offset: 20,
            font: {
              weight: 'bold'
            }
          },
          // Hide default legend
          legend: {
            // display: false
          }
        },

      },
      plugins: [ChartDataLabels]
    };

    // Create the chart and store it in a global variable
    window.currentChart = new Chart(ctx, chartConfig);

    // Function to update the progress slider
    function updateProgressSlider(index) {
      // Update slider value
      document.getElementById('progressSlider').value = index;
    }

    // Update progress slider for initial month
    updateProgressSlider(window.currentMonthIndex);

    // Set up animation interval (update every 2 seconds)
    setInterval(() => {
      // Move to next month (cycle back to start when reaching the end)
      window.currentMonthIndex = (window.currentMonthIndex + 1) % months.length;

      // Update month label
      document.getElementById('monthLabel').textContent = months[window.currentMonthIndex];

      // Update progress slider
      updateProgressSlider(window.currentMonthIndex);

      // Get current enabled cryptocurrencies
      const currentEnabledCryptos = getEnabledCryptos();

      // Update chart data with new percentages
      window.currentChart.data.labels = currentEnabledCryptos;
      window.currentChart.data.datasets[0].data = calculatePercentages(window.currentMonthIndex, currentEnabledCryptos);
      window.currentChart.data.datasets[0].backgroundColor = currentEnabledCryptos.map(crypto => coins[crypto].color);

      // Redraw the chart
      window.currentChart.update();
    }, 2000);
  }

  // Initialize the application when the DOM is fully loaded
  document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
